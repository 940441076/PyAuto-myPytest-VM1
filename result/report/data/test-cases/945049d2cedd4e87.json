{"uid":"945049d2cedd4e87","name":"筛选和条件搜索","fullName":"testcases.patientList.test_patientList.Test_PatientListPage#test_filter_search","historyId":"10c73b85c38e0b3251ebce0240352252","time":{"start":1688527134490,"stop":1688527694168,"duration":559678},"description":"筛选类型后，输入不同的关键词搜索，对比结果","descriptionHtml":"<p>筛选类型后，输入不同的关键词搜索，对比结果</p>\n","status":"failed","statusMessage":"AssertionError: assert False","statusTrace":"self = <pywinauto.application.WindowSpecification object at 0x000001C61F5FABD0>\ncriteria = [{'app': <pywinauto.application.Application object at 0x000001C61F610F10>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False}]\ntimeout = 5.0, retry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n>           ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n                criteria)\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:250: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ntimeout = 5.0, retry_interval = 0.09\nfunc = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x000001C61F5FABD0>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'app': <pywinauto.application.Application object at 0x000001C61F610F10>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False}],)\nkwargs = {}, start = 11767.5893404, time_left = -0.05517180000060762\nerr = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n                func_val = func(*args, **kwargs)\n    \n                # if no exception is raised then we are finished\n                break\n    \n            # An exception was raised - so wait and try again\n            except exceptions as e:\n    \n                # find out how much of the time is left\n                time_left = timeout - (timestamp() - start)\n    \n                # if we have to wait some more\n                if time_left > 0:\n                    # wait either the retry_interval or else the amount of\n                    # time until the timeout expires (whichever is less)\n                    time.sleep(min(retry_interval, time_left))\n    \n                else:\n                    # Raise a TimeoutError - and put the original exception\n                    # inside it\n                    err = TimeoutError()\n                    err.original_exception = e\n>                   raise err\nE                   pywinauto.timings.TimeoutError\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\timings.py:458: TimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_patientList.Test_PatientListPage object at 0x000001C61ECDED90>\n\n    @allure.title('筛选和条件搜索')\n    def test_filter_search(self):\n        allure.dynamic.description('筛选类型后，输入不同的关键词搜索，对比结果')\n        try:\n            app = common_util.connect_application()\n            common_util.del_all_patients()\n            common_util.import_testdata(index=1)\n            time.sleep(2)\n            common_util.back_patientListPage()\n            with allure.step('选择不同类型，判断筛选结果'):\n                OCT_type = app['血管内断层成像系统'].child_window(auto_id=\"cmbType\", control_type=\"ComboBox\")\n>               type = OCT_type.texts()\n\ntestcases\\patientList\\test_patientList.py:147: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x000001C61F5FABD0>\nattr_name = 'texts'\n\n    def __getattribute__(self, attr_name):\n        \"\"\"\n        Attribute access for this class\n    \n        If we already have criteria for both dialog and control then\n        resolve the control and return the requested attribute.\n    \n        If we have only criteria for the dialog but the attribute\n        requested is an attribute of DialogWrapper then resolve the\n        dialog and return the requested attribute.\n    \n        Otherwise delegate functionality to :func:`__getitem__` - which\n        sets the appropriate criteria for the control.\n        \"\"\"\n        allow_magic_lookup = object.__getattribute__(self, \"allow_magic_lookup\")  # Beware of recursions here!\n        if not allow_magic_lookup:\n            try:\n                return object.__getattribute__(self, attr_name)\n            except AttributeError:\n                wrapper_object = self.wrapper_object()\n                try:\n                    return getattr(wrapper_object, attr_name)\n                except AttributeError:\n                    message = (\n                        'Attribute \"%s\" exists neither on %s object nor on'\n                        'targeted %s element wrapper (typo? or set allow_magic_lookup to True?)' %\n                        (attr_name, self.__class__, wrapper_object.__class__))\n                    raise AttributeError(message)\n    \n        if attr_name in ['__dict__', '__members__', '__methods__', '__class__', '__name__']:\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in dir(self.__class__):\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in self.__dict__:\n            return self.__dict__[attr_name]\n    \n        # if we already have 2 levels of criteria (dlg, control)\n        # this third must be an attribute so resolve and get the\n        # attribute and return it\n        if len(self.criteria) >= 2:  # FIXME - this is surprising\n    \n>           ctrls = self.__resolve_control(self.criteria)\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:379: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x000001C61F5FABD0>\ncriteria = [{'app': <pywinauto.application.Application object at 0x000001C61F610F10>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False}]\ntimeout = 5.0, retry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n            ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n                criteria)\n    \n        except TimeoutError as e:\n>           raise e.original_exception\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:261: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ntimeout = 5.0, retry_interval = 0.09\nfunc = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x000001C61F5FABD0>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'app': <pywinauto.application.Application object at 0x000001C61F610F10>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False}],)\nkwargs = {}, start = 11767.5893404, time_left = -0.05517180000060762\nerr = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n>               func_val = func(*args, **kwargs)\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\timings.py:436: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x000001C61F5FABD0>\ncriteria_ = [{'app': <pywinauto.application.Application object at 0x000001C61F610F10>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False}]\n\n    def __get_ctrl(self, criteria_):\n        \"\"\"Get a control based on the various criteria\"\"\"\n        # make a copy of the criteria\n        criteria = [crit.copy() for crit in criteria_]\n        # find the dialog\n        if 'backend' not in criteria[0]:\n            criteria[0]['backend'] = self.backend.name\n        if self.app is not None:\n            # find_elements(...) accepts only \"process\" argument\n            criteria[0]['process'] = self.app.process\n            del criteria[0]['app']\n        dialog = self.backend.generic_wrapper_class(findwindows.find_element(**criteria[0]))\n    \n        ctrls = []\n        # if there is only criteria for a dialog then return it\n        if len(criteria) > 1:\n            # so there was criteria for a control, add the extra criteria\n            # that are required for child controls\n            previous_parent = dialog.element_info\n            for ctrl_criteria in criteria[1:]:\n                ctrl_criteria[\"top_level_only\"] = False\n                if \"parent\" not in ctrl_criteria:\n                    ctrl_criteria[\"parent\"] = previous_parent\n    \n                if isinstance(ctrl_criteria[\"parent\"], WindowSpecification):\n                    ctrl_criteria[\"parent\"] = ctrl_criteria[\"parent\"].wrapper_object()\n    \n                # resolve the control and return it\n                if 'backend' not in ctrl_criteria:\n                    ctrl_criteria['backend'] = self.backend.name\n>               ctrl = self.backend.generic_wrapper_class(findwindows.find_element(**ctrl_criteria))\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:222: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nkwargs = {'auto_id': 'cmbType', 'backend': 'uia', 'control_type': 'ComboBox', 'parent': <uia_element_info.UIAElementInfo - '', , None>, ...}\nelements = []\n\n    def find_element(**kwargs):\n        \"\"\"\n        Call find_elements and ensure that only one element is returned\n    \n        Calls find_elements with exactly the same arguments as it is called with\n        so please see :py:func:`find_elements` for the full parameters description.\n        \"\"\"\n        elements = find_elements(**kwargs)\n    \n        if not elements:\n>           raise ElementNotFoundError(kwargs)\nE           pywinauto.findwindows.ElementNotFoundError: {'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False, 'parent': <uia_element_info.UIAElementInfo - '', , None>, 'backend': 'uia'}\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\findwindows.py:87: ElementNotFoundError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_patientList.Test_PatientListPage object at 0x000001C61ECDED90>\n\n    @allure.title('筛选和条件搜索')\n    def test_filter_search(self):\n        allure.dynamic.description('筛选类型后，输入不同的关键词搜索，对比结果')\n        try:\n            app = common_util.connect_application()\n            common_util.del_all_patients()\n            common_util.import_testdata(index=1)\n            time.sleep(2)\n            common_util.back_patientListPage()\n            with allure.step('选择不同类型，判断筛选结果'):\n                OCT_type = app['血管内断层成像系统'].child_window(auto_id=\"cmbType\", control_type=\"ComboBox\")\n                type = OCT_type.texts()\n                for i in range(len(type)):\n                    OCT_type.select(i + 1)\n                    time.sleep(1)\n                    if type[i] == 'ALL':\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        assert len(patient_info) == 4\n                        time.sleep(1)\n                        common_util.screen_shot('未筛选时结果')\n                        search_edit = app['血管内断层成像系统'].child_window(auto_id=\"autoText\",\n                                                                                  control_type=\"Edit\")\n                        search_edit.type_keys('备注')\n                        search_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSearch\",\n                                                                                 control_type=\"Button\")\n                        search_btn.click()\n                        time.sleep(1)\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        mark = []\n                        for j in range(len(patient_info)):\n                            mark.append(patient_info[j][7])\n                        assert mark == ['备注DSA', '备注OCT']\n                        time.sleep(1)\n                        common_util.screen_shot('ALL结果')\n                        clear_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClear\",\n                                                                                control_type=\"Button\")\n                        clear_btn.click()\n                        time.sleep(1)\n                        search_edit.type_keys('测试')\n                        search_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSearch\",\n                                                                                 control_type=\"Button\")\n                        search_btn.click()\n                        time.sleep(1)\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        assert 0 == len(patient_info)\n                        clear_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClear\",\n                                                                                control_type=\"Button\")\n                        clear_btn.click()\n                        time.sleep(1)\n                    elif type[i] == 'OCT':\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        assert len(patient_info)== 1\n                        search_edit = app['血管内断层成像系统'].child_window(auto_id=\"autoText\",\n                                                                                  control_type=\"Edit\")\n                        search_edit.type_keys('备注')\n                        search_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSearch\",\n                                                                                 control_type=\"Button\")\n                        search_btn.click()\n                        time.sleep(1)\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        mark = []\n                        for j in range(len(patient_info)):\n                            mark.append(patient_info[j][7])\n                        assert mark == ['备注OCT']\n                        time.sleep(1)\n                        common_util.screen_shot('OCT结果')\n                        clear_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClear\",\n                                                                                control_type=\"Button\")\n                        clear_btn.click()\n                        time.sleep(1)\n                        search_edit.type_keys('测试')\n                        search_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSearch\",\n                                                                                 control_type=\"Button\")\n                        search_btn.click()\n                        time.sleep(1)\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        assert 0== len(patient_info)\n                        clear_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClear\",\n                                                                                control_type=\"Button\")\n                        clear_btn.click()\n                        time.sleep(1)\n                    elif type[i] == 'OCT-DSA':\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        assert len(patient_info)== 3\n                        search_edit = app['血管内断层成像系统'].child_window(auto_id=\"autoText\",\n                                                                                  control_type=\"Edit\")\n                        search_edit.type_keys('备注')\n                        search_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSearch\",\n                                                                                 control_type=\"Button\")\n                        search_btn.click()\n                        time.sleep(1)\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        mark = []\n                        for j in range(len(patient_info)):\n                            mark.append(patient_info[j][7])\n                        assert mark==['备注DSA']\n                        time.sleep(1)\n                        common_util.screen_shot('OCT-DSA结果')\n                        clear_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClear\",\n                                                                                control_type=\"Button\")\n                        clear_btn.click()\n                        time.sleep(1)\n                        search_edit.type_keys('测试')\n                        content = search_edit.texts()\n                        assert ['测试'] == content\n                        search_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSearch\",\n                                                                                 control_type=\"Button\")\n                        search_btn.click()\n                        time.sleep(1)\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        assert 0== len(patient_info)\n    \n                        clear_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClear\",\n                                                                                control_type=\"Button\")\n                        clear_btn.click()\n                        time.sleep(1)\n                        content = search_edit.texts()\n                        assert [''] == content\n                        time.sleep(1)\n                time.sleep(1)\n        except Exception as e:\n            time.sleep(1)\n            common_util.screen_shot('异常截图')\n            time.sleep(1)\n            common_util.kill_app()\n            time.sleep(2)\n            common_util.connect_application()\n            common_util.add_text(str(e))\n>           assert False\nE           assert False\n\ntestcases\\patientList\\test_patientList.py:282: AssertionError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"_session_faker","time":{"start":1688524990855,"stop":1688524990916,"duration":61},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"stepsCount":0,"hasContent":false},{"name":"environ","time":{"start":1688524990916,"stop":1688524990917,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"stepsCount":0,"hasContent":false},{"name":"base_url","time":{"start":1688524990916,"stop":1688524990916,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"stepsCount":0,"hasContent":false},{"name":"_verify_url","time":{"start":1688524990916,"stop":1688524990916,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"stepsCount":0,"hasContent":false}],"testStage":{"description":"筛选类型后，输入不同的关键词搜索，对比结果","status":"failed","statusMessage":"AssertionError: assert False","statusTrace":"self = <pywinauto.application.WindowSpecification object at 0x000001C61F5FABD0>\ncriteria = [{'app': <pywinauto.application.Application object at 0x000001C61F610F10>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False}]\ntimeout = 5.0, retry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n>           ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n                criteria)\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:250: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ntimeout = 5.0, retry_interval = 0.09\nfunc = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x000001C61F5FABD0>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'app': <pywinauto.application.Application object at 0x000001C61F610F10>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False}],)\nkwargs = {}, start = 11767.5893404, time_left = -0.05517180000060762\nerr = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n                func_val = func(*args, **kwargs)\n    \n                # if no exception is raised then we are finished\n                break\n    \n            # An exception was raised - so wait and try again\n            except exceptions as e:\n    \n                # find out how much of the time is left\n                time_left = timeout - (timestamp() - start)\n    \n                # if we have to wait some more\n                if time_left > 0:\n                    # wait either the retry_interval or else the amount of\n                    # time until the timeout expires (whichever is less)\n                    time.sleep(min(retry_interval, time_left))\n    \n                else:\n                    # Raise a TimeoutError - and put the original exception\n                    # inside it\n                    err = TimeoutError()\n                    err.original_exception = e\n>                   raise err\nE                   pywinauto.timings.TimeoutError\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\timings.py:458: TimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_patientList.Test_PatientListPage object at 0x000001C61ECDED90>\n\n    @allure.title('筛选和条件搜索')\n    def test_filter_search(self):\n        allure.dynamic.description('筛选类型后，输入不同的关键词搜索，对比结果')\n        try:\n            app = common_util.connect_application()\n            common_util.del_all_patients()\n            common_util.import_testdata(index=1)\n            time.sleep(2)\n            common_util.back_patientListPage()\n            with allure.step('选择不同类型，判断筛选结果'):\n                OCT_type = app['血管内断层成像系统'].child_window(auto_id=\"cmbType\", control_type=\"ComboBox\")\n>               type = OCT_type.texts()\n\ntestcases\\patientList\\test_patientList.py:147: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x000001C61F5FABD0>\nattr_name = 'texts'\n\n    def __getattribute__(self, attr_name):\n        \"\"\"\n        Attribute access for this class\n    \n        If we already have criteria for both dialog and control then\n        resolve the control and return the requested attribute.\n    \n        If we have only criteria for the dialog but the attribute\n        requested is an attribute of DialogWrapper then resolve the\n        dialog and return the requested attribute.\n    \n        Otherwise delegate functionality to :func:`__getitem__` - which\n        sets the appropriate criteria for the control.\n        \"\"\"\n        allow_magic_lookup = object.__getattribute__(self, \"allow_magic_lookup\")  # Beware of recursions here!\n        if not allow_magic_lookup:\n            try:\n                return object.__getattribute__(self, attr_name)\n            except AttributeError:\n                wrapper_object = self.wrapper_object()\n                try:\n                    return getattr(wrapper_object, attr_name)\n                except AttributeError:\n                    message = (\n                        'Attribute \"%s\" exists neither on %s object nor on'\n                        'targeted %s element wrapper (typo? or set allow_magic_lookup to True?)' %\n                        (attr_name, self.__class__, wrapper_object.__class__))\n                    raise AttributeError(message)\n    \n        if attr_name in ['__dict__', '__members__', '__methods__', '__class__', '__name__']:\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in dir(self.__class__):\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in self.__dict__:\n            return self.__dict__[attr_name]\n    \n        # if we already have 2 levels of criteria (dlg, control)\n        # this third must be an attribute so resolve and get the\n        # attribute and return it\n        if len(self.criteria) >= 2:  # FIXME - this is surprising\n    \n>           ctrls = self.__resolve_control(self.criteria)\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:379: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x000001C61F5FABD0>\ncriteria = [{'app': <pywinauto.application.Application object at 0x000001C61F610F10>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False}]\ntimeout = 5.0, retry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n            ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n                criteria)\n    \n        except TimeoutError as e:\n>           raise e.original_exception\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:261: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ntimeout = 5.0, retry_interval = 0.09\nfunc = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x000001C61F5FABD0>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'app': <pywinauto.application.Application object at 0x000001C61F610F10>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False}],)\nkwargs = {}, start = 11767.5893404, time_left = -0.05517180000060762\nerr = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n>               func_val = func(*args, **kwargs)\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\timings.py:436: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x000001C61F5FABD0>\ncriteria_ = [{'app': <pywinauto.application.Application object at 0x000001C61F610F10>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False}]\n\n    def __get_ctrl(self, criteria_):\n        \"\"\"Get a control based on the various criteria\"\"\"\n        # make a copy of the criteria\n        criteria = [crit.copy() for crit in criteria_]\n        # find the dialog\n        if 'backend' not in criteria[0]:\n            criteria[0]['backend'] = self.backend.name\n        if self.app is not None:\n            # find_elements(...) accepts only \"process\" argument\n            criteria[0]['process'] = self.app.process\n            del criteria[0]['app']\n        dialog = self.backend.generic_wrapper_class(findwindows.find_element(**criteria[0]))\n    \n        ctrls = []\n        # if there is only criteria for a dialog then return it\n        if len(criteria) > 1:\n            # so there was criteria for a control, add the extra criteria\n            # that are required for child controls\n            previous_parent = dialog.element_info\n            for ctrl_criteria in criteria[1:]:\n                ctrl_criteria[\"top_level_only\"] = False\n                if \"parent\" not in ctrl_criteria:\n                    ctrl_criteria[\"parent\"] = previous_parent\n    \n                if isinstance(ctrl_criteria[\"parent\"], WindowSpecification):\n                    ctrl_criteria[\"parent\"] = ctrl_criteria[\"parent\"].wrapper_object()\n    \n                # resolve the control and return it\n                if 'backend' not in ctrl_criteria:\n                    ctrl_criteria['backend'] = self.backend.name\n>               ctrl = self.backend.generic_wrapper_class(findwindows.find_element(**ctrl_criteria))\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:222: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nkwargs = {'auto_id': 'cmbType', 'backend': 'uia', 'control_type': 'ComboBox', 'parent': <uia_element_info.UIAElementInfo - '', , None>, ...}\nelements = []\n\n    def find_element(**kwargs):\n        \"\"\"\n        Call find_elements and ensure that only one element is returned\n    \n        Calls find_elements with exactly the same arguments as it is called with\n        so please see :py:func:`find_elements` for the full parameters description.\n        \"\"\"\n        elements = find_elements(**kwargs)\n    \n        if not elements:\n>           raise ElementNotFoundError(kwargs)\nE           pywinauto.findwindows.ElementNotFoundError: {'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False, 'parent': <uia_element_info.UIAElementInfo - '', , None>, 'backend': 'uia'}\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\findwindows.py:87: ElementNotFoundError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_patientList.Test_PatientListPage object at 0x000001C61ECDED90>\n\n    @allure.title('筛选和条件搜索')\n    def test_filter_search(self):\n        allure.dynamic.description('筛选类型后，输入不同的关键词搜索，对比结果')\n        try:\n            app = common_util.connect_application()\n            common_util.del_all_patients()\n            common_util.import_testdata(index=1)\n            time.sleep(2)\n            common_util.back_patientListPage()\n            with allure.step('选择不同类型，判断筛选结果'):\n                OCT_type = app['血管内断层成像系统'].child_window(auto_id=\"cmbType\", control_type=\"ComboBox\")\n                type = OCT_type.texts()\n                for i in range(len(type)):\n                    OCT_type.select(i + 1)\n                    time.sleep(1)\n                    if type[i] == 'ALL':\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        assert len(patient_info) == 4\n                        time.sleep(1)\n                        common_util.screen_shot('未筛选时结果')\n                        search_edit = app['血管内断层成像系统'].child_window(auto_id=\"autoText\",\n                                                                                  control_type=\"Edit\")\n                        search_edit.type_keys('备注')\n                        search_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSearch\",\n                                                                                 control_type=\"Button\")\n                        search_btn.click()\n                        time.sleep(1)\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        mark = []\n                        for j in range(len(patient_info)):\n                            mark.append(patient_info[j][7])\n                        assert mark == ['备注DSA', '备注OCT']\n                        time.sleep(1)\n                        common_util.screen_shot('ALL结果')\n                        clear_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClear\",\n                                                                                control_type=\"Button\")\n                        clear_btn.click()\n                        time.sleep(1)\n                        search_edit.type_keys('测试')\n                        search_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSearch\",\n                                                                                 control_type=\"Button\")\n                        search_btn.click()\n                        time.sleep(1)\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        assert 0 == len(patient_info)\n                        clear_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClear\",\n                                                                                control_type=\"Button\")\n                        clear_btn.click()\n                        time.sleep(1)\n                    elif type[i] == 'OCT':\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        assert len(patient_info)== 1\n                        search_edit = app['血管内断层成像系统'].child_window(auto_id=\"autoText\",\n                                                                                  control_type=\"Edit\")\n                        search_edit.type_keys('备注')\n                        search_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSearch\",\n                                                                                 control_type=\"Button\")\n                        search_btn.click()\n                        time.sleep(1)\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        mark = []\n                        for j in range(len(patient_info)):\n                            mark.append(patient_info[j][7])\n                        assert mark == ['备注OCT']\n                        time.sleep(1)\n                        common_util.screen_shot('OCT结果')\n                        clear_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClear\",\n                                                                                control_type=\"Button\")\n                        clear_btn.click()\n                        time.sleep(1)\n                        search_edit.type_keys('测试')\n                        search_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSearch\",\n                                                                                 control_type=\"Button\")\n                        search_btn.click()\n                        time.sleep(1)\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        assert 0== len(patient_info)\n                        clear_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClear\",\n                                                                                control_type=\"Button\")\n                        clear_btn.click()\n                        time.sleep(1)\n                    elif type[i] == 'OCT-DSA':\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        assert len(patient_info)== 3\n                        search_edit = app['血管内断层成像系统'].child_window(auto_id=\"autoText\",\n                                                                                  control_type=\"Edit\")\n                        search_edit.type_keys('备注')\n                        search_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSearch\",\n                                                                                 control_type=\"Button\")\n                        search_btn.click()\n                        time.sleep(1)\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        mark = []\n                        for j in range(len(patient_info)):\n                            mark.append(patient_info[j][7])\n                        assert mark==['备注DSA']\n                        time.sleep(1)\n                        common_util.screen_shot('OCT-DSA结果')\n                        clear_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClear\",\n                                                                                control_type=\"Button\")\n                        clear_btn.click()\n                        time.sleep(1)\n                        search_edit.type_keys('测试')\n                        content = search_edit.texts()\n                        assert ['测试'] == content\n                        search_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSearch\",\n                                                                                 control_type=\"Button\")\n                        search_btn.click()\n                        time.sleep(1)\n                        patient_list = app['血管内断层成像系统'].child_window(auto_id=\"dataGridPatientInfo\",\n                                                                                   control_type=\"DataGrid\")\n                        patient_info = patient_list.texts()\n                        assert 0== len(patient_info)\n    \n                        clear_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClear\",\n                                                                                control_type=\"Button\")\n                        clear_btn.click()\n                        time.sleep(1)\n                        content = search_edit.texts()\n                        assert [''] == content\n                        time.sleep(1)\n                time.sleep(1)\n        except Exception as e:\n            time.sleep(1)\n            common_util.screen_shot('异常截图')\n            time.sleep(1)\n            common_util.kill_app()\n            time.sleep(2)\n            common_util.connect_application()\n            common_util.add_text(str(e))\n>           assert False\nE           assert False\n\ntestcases\\patientList\\test_patientList.py:282: AssertionError","steps":[{"name":"选择不同类型，判断筛选结果","time":{"start":1688527668661,"stop":1688527673716,"duration":5055},"status":"broken","statusMessage":"pywinauto.findwindows.ElementNotFoundError: {'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False, 'parent': <uia_element_info.UIAElementInfo - '血管内光学干涉断层成像系统', Window, 1639180>, 'backend': 'uia'}\n","statusTrace":"  File \"D:\\workspace\\myPytest\\VM1\\testcases\\patientList\\test_patientList.py\", line 147, in test_filter_search\n    type = OCT_type.texts()\n           ^^^^^^^^^^^^^^\n  File \"C:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py\", line 379, in __getattribute__\n    ctrls = self.__resolve_control(self.criteria)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py\", line 261, in __resolve_control\n    raise e.original_exception\n  File \"C:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\timings.py\", line 436, in wait_until_passes\n    func_val = func(*args, **kwargs)\n               ^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py\", line 222, in __get_ctrl\n    ctrl = self.backend.generic_wrapper_class(findwindows.find_element(**ctrl_criteria))\n                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\findwindows.py\", line 87, in find_element\n    raise ElementNotFoundError(kwargs)\n","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"attachmentsCount":0,"stepsCount":0,"hasContent":true}],"attachments":[{"uid":"d47c0c3426c25a92","name":"异常：import_testdata","source":"d47c0c3426c25a92.jpg","type":"image/jpg","size":56197},{"uid":"9e22ca001c2a25d1","name":"异常截图","source":"9e22ca001c2a25d1.jpg","type":"image/jpg","size":56188},{"uid":"edd189c907af44d4","name":"{'auto_id': 'cmbType', 'control_type': 'ComboBox', 'top_level_only': False, 'parent': <uia_element_info.UIAElementInfo - '', , None>, 'backend': 'uia'}","source":"edd189c907af44d4.txt","type":"text/plain","size":0}],"parameters":[],"shouldDisplayMessage":true,"attachmentsCount":3,"stepsCount":1,"hasContent":true},"afterStages":[],"labels":[{"name":"feature","value":"患者列表界面"},{"name":"tag","value":"run(order=2)"},{"name":"parentSuite","value":"testcases.patientList"},{"name":"suite","value":"test_patientList"},{"name":"subSuite","value":"Test_PatientListPage"},{"name":"host","value":"DESKTOP-8BNU2EL"},{"name":"thread","value":"5300-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"testcases.patientList.test_patientList"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"tags":["run(order=2)"]},"source":"945049d2cedd4e87.json","parameterValues":[]}