{"uid":"ca8a55cdc611ad25","name":"回撤-6k","fullName":"testcases.scanImage.test_scanImage.Test_ScanImagePage#test_pullback_6k","historyId":"d4c75ce40c34e87b4a689ac07c2e2d34","time":{"start":1691373084169,"stop":1691373137762,"duration":53593},"description":"回撤-6k","descriptionHtml":"<p>回撤-6k</p>\n","status":"failed","statusMessage":"AssertionError: assert False","statusTrace":"self = <pywinauto.application.WindowSpecification object at 0x0000028CA661A110>\ncriteria = [{'app': <pywinauto.application.Application object at 0x0000028CA6666F90>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False}]\ntimeout = 5.0, retry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n>           ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n                criteria)\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:250: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ntimeout = 5.0, retry_interval = 0.09\nfunc = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x0000028CA661A110>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'app': <pywinauto.application.Application object at 0x0000028CA6666F90>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False}],)\nkwargs = {}, start = 5527.1790851, time_left = -0.06389110000054643\nerr = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n                func_val = func(*args, **kwargs)\n    \n                # if no exception is raised then we are finished\n                break\n    \n            # An exception was raised - so wait and try again\n            except exceptions as e:\n    \n                # find out how much of the time is left\n                time_left = timeout - (timestamp() - start)\n    \n                # if we have to wait some more\n                if time_left > 0:\n                    # wait either the retry_interval or else the amount of\n                    # time until the timeout expires (whichever is less)\n                    time.sleep(min(retry_interval, time_left))\n    \n                else:\n                    # Raise a TimeoutError - and put the original exception\n                    # inside it\n                    err = TimeoutError()\n                    err.original_exception = e\n>                   raise err\nE                   pywinauto.timings.TimeoutError\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\timings.py:458: TimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_scanImage.Test_ScanImagePage object at 0x0000028CA54CE650>\n\n    @pytest.mark.test\n    @allure.title('回撤-6k')\n    def test_pullback_6k(self):\n        allure.dynamic.description('回撤-6k')\n        try:\n            app = common_util.connect_application()\n            common_util.back_scanImagePage()\n            with allure.step('6k:不同转速和距离'):\n                # 6k转\n                setting_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSetting\", control_type=\"Button\")\n                setting_btn.click_input()\n                play_type = app['血管内断层成像系统'].child_window(auto_id=\"comLoop\", control_type=\"ComboBox\", found_index=0)\n                play_type.select(0)\n                play_speed = app['血管内断层成像系统'].child_window(auto_id=\"playbackSpeed\", control_type=\"Slider\", found_index=0)\n                play_speed.set_value(10)\n                k6_btn = app['血管内断层成像系统'].child_window(title=\"6k转\", auto_id=\"rbRotateSpeed6000\",control_type=\"RadioButton\", found_index=0)\n                k6_btn.click()\n                pull_len = app['血管内断层成像系统'].child_window(auto_id=\"comPullback\", control_type=\"ComboBox\")\n                pull_len.select(0)\n                content_len = pull_len.texts()\n                for i in range(len(content_len)):\n                    setting_close_btn = app['血管内断层成像系统'].child_window(auto_id=\"closeSetting\", control_type=\"Button\")\n                    if setting_close_btn.exists() == False:\n                        setting_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSetting\", control_type=\"Button\")\n                        setting_btn.click_input()\n                    pull_len.select(i)\n                    pull_speed = app['血管内断层成像系统'].child_window(auto_id=\"comPullBackSped\",control_type=\"ComboBox\")\n                    pull_speed.select(0)\n                    content_speed = pull_speed.texts()\n                    for j in range(len(content_speed)):\n                        setting_close_btn = app['血管内断层成像系统'].child_window(auto_id=\"closeSetting\", control_type=\"Button\")\n                        if setting_close_btn.exists() == False:\n                            setting_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSetting\", control_type=\"Button\")\n                            setting_btn.click_input()\n                        pull_speed.select(j)\n                        time.sleep(1)\n                        setting_close_btn = app['血管内断层成像系统'].child_window(auto_id=\"closeSetting\", control_type=\"Button\")\n                        setting_close_btn.click()\n                        time.sleep(1)\n                        dsa = common_util.read_systemInfo()\n                        if dsa['DSA'] == True:\n                            dsa_btn = app['血管内断层成像系统'].child_window(title=\"显示DSA\", control_type=\"Text\", found_index=0)\n                            if dsa_btn.exists():\n                                dsa_btn = app['血管内断层成像系统'].child_window(title=\"显示DSA\", auto_id=\"btnShow\",control_type=\"Button\")\n                                dsa_btn.click_input()\n                        time.sleep(1)\n                        scan_btn = app['血管内断层成像系统'].child_window(auto_id=\"staScan\", control_type=\"Button\")\n                        scan_btn.click()\n                        time.sleep(5)\n                        if i == 0 and j == 0:\n                            calibration_btn = app['血管内断层成像系统'].child_window(auto_id=\"autoCalibration\",control_type=\"Button\")\n                            calibration_btn.click()\n                            time.sleep(13)\n                        ok_btn = app['提示'].child_window(title=\"确 定\", auto_id=\"OkButton\", control_type=\"Button\")\n                        if ok_btn.exists():\n                            ok_btn.click()\n                        else:\n                            stop_btn = app['血管内断层成像系统'].child_window(auto_id=\"stopScan\", control_type=\"Button\")\n>                           stop_btn.click()\n\ntestcases\\scanImage\\test_scanImage.py:145: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x0000028CA661A110>\nattr_name = 'click'\n\n    def __getattribute__(self, attr_name):\n        \"\"\"\n        Attribute access for this class\n    \n        If we already have criteria for both dialog and control then\n        resolve the control and return the requested attribute.\n    \n        If we have only criteria for the dialog but the attribute\n        requested is an attribute of DialogWrapper then resolve the\n        dialog and return the requested attribute.\n    \n        Otherwise delegate functionality to :func:`__getitem__` - which\n        sets the appropriate criteria for the control.\n        \"\"\"\n        allow_magic_lookup = object.__getattribute__(self, \"allow_magic_lookup\")  # Beware of recursions here!\n        if not allow_magic_lookup:\n            try:\n                return object.__getattribute__(self, attr_name)\n            except AttributeError:\n                wrapper_object = self.wrapper_object()\n                try:\n                    return getattr(wrapper_object, attr_name)\n                except AttributeError:\n                    message = (\n                        'Attribute \"%s\" exists neither on %s object nor on'\n                        'targeted %s element wrapper (typo? or set allow_magic_lookup to True?)' %\n                        (attr_name, self.__class__, wrapper_object.__class__))\n                    raise AttributeError(message)\n    \n        if attr_name in ['__dict__', '__members__', '__methods__', '__class__', '__name__']:\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in dir(self.__class__):\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in self.__dict__:\n            return self.__dict__[attr_name]\n    \n        # if we already have 2 levels of criteria (dlg, control)\n        # this third must be an attribute so resolve and get the\n        # attribute and return it\n        if len(self.criteria) >= 2:  # FIXME - this is surprising\n    \n>           ctrls = self.__resolve_control(self.criteria)\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:379: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x0000028CA661A110>\ncriteria = [{'app': <pywinauto.application.Application object at 0x0000028CA6666F90>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False}]\ntimeout = 5.0, retry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n            ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n                criteria)\n    \n        except TimeoutError as e:\n>           raise e.original_exception\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:261: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ntimeout = 5.0, retry_interval = 0.09\nfunc = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x0000028CA661A110>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'app': <pywinauto.application.Application object at 0x0000028CA6666F90>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False}],)\nkwargs = {}, start = 5527.1790851, time_left = -0.06389110000054643\nerr = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n>               func_val = func(*args, **kwargs)\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\timings.py:436: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x0000028CA661A110>\ncriteria_ = [{'app': <pywinauto.application.Application object at 0x0000028CA6666F90>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False}]\n\n    def __get_ctrl(self, criteria_):\n        \"\"\"Get a control based on the various criteria\"\"\"\n        # make a copy of the criteria\n        criteria = [crit.copy() for crit in criteria_]\n        # find the dialog\n        if 'backend' not in criteria[0]:\n            criteria[0]['backend'] = self.backend.name\n        if self.app is not None:\n            # find_elements(...) accepts only \"process\" argument\n            criteria[0]['process'] = self.app.process\n            del criteria[0]['app']\n        dialog = self.backend.generic_wrapper_class(findwindows.find_element(**criteria[0]))\n    \n        ctrls = []\n        # if there is only criteria for a dialog then return it\n        if len(criteria) > 1:\n            # so there was criteria for a control, add the extra criteria\n            # that are required for child controls\n            previous_parent = dialog.element_info\n            for ctrl_criteria in criteria[1:]:\n                ctrl_criteria[\"top_level_only\"] = False\n                if \"parent\" not in ctrl_criteria:\n                    ctrl_criteria[\"parent\"] = previous_parent\n    \n                if isinstance(ctrl_criteria[\"parent\"], WindowSpecification):\n                    ctrl_criteria[\"parent\"] = ctrl_criteria[\"parent\"].wrapper_object()\n    \n                # resolve the control and return it\n                if 'backend' not in ctrl_criteria:\n                    ctrl_criteria['backend'] = self.backend.name\n>               ctrl = self.backend.generic_wrapper_class(findwindows.find_element(**ctrl_criteria))\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:222: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nkwargs = {'auto_id': 'stopScan', 'backend': 'uia', 'control_type': 'Button', 'parent': <uia_element_info.UIAElementInfo - '', , None>, ...}\nelements = []\n\n    def find_element(**kwargs):\n        \"\"\"\n        Call find_elements and ensure that only one element is returned\n    \n        Calls find_elements with exactly the same arguments as it is called with\n        so please see :py:func:`find_elements` for the full parameters description.\n        \"\"\"\n        elements = find_elements(**kwargs)\n    \n        if not elements:\n>           raise ElementNotFoundError(kwargs)\nE           pywinauto.findwindows.ElementNotFoundError: {'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False, 'parent': <uia_element_info.UIAElementInfo - '', , None>, 'backend': 'uia'}\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\findwindows.py:87: ElementNotFoundError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_scanImage.Test_ScanImagePage object at 0x0000028CA54CE650>\n\n    @pytest.mark.test\n    @allure.title('回撤-6k')\n    def test_pullback_6k(self):\n        allure.dynamic.description('回撤-6k')\n        try:\n            app = common_util.connect_application()\n            common_util.back_scanImagePage()\n            with allure.step('6k:不同转速和距离'):\n                # 6k转\n                setting_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSetting\", control_type=\"Button\")\n                setting_btn.click_input()\n                play_type = app['血管内断层成像系统'].child_window(auto_id=\"comLoop\", control_type=\"ComboBox\", found_index=0)\n                play_type.select(0)\n                play_speed = app['血管内断层成像系统'].child_window(auto_id=\"playbackSpeed\", control_type=\"Slider\", found_index=0)\n                play_speed.set_value(10)\n                k6_btn = app['血管内断层成像系统'].child_window(title=\"6k转\", auto_id=\"rbRotateSpeed6000\",control_type=\"RadioButton\", found_index=0)\n                k6_btn.click()\n                pull_len = app['血管内断层成像系统'].child_window(auto_id=\"comPullback\", control_type=\"ComboBox\")\n                pull_len.select(0)\n                content_len = pull_len.texts()\n                for i in range(len(content_len)):\n                    setting_close_btn = app['血管内断层成像系统'].child_window(auto_id=\"closeSetting\", control_type=\"Button\")\n                    if setting_close_btn.exists() == False:\n                        setting_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSetting\", control_type=\"Button\")\n                        setting_btn.click_input()\n                    pull_len.select(i)\n                    pull_speed = app['血管内断层成像系统'].child_window(auto_id=\"comPullBackSped\",control_type=\"ComboBox\")\n                    pull_speed.select(0)\n                    content_speed = pull_speed.texts()\n                    for j in range(len(content_speed)):\n                        setting_close_btn = app['血管内断层成像系统'].child_window(auto_id=\"closeSetting\", control_type=\"Button\")\n                        if setting_close_btn.exists() == False:\n                            setting_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSetting\", control_type=\"Button\")\n                            setting_btn.click_input()\n                        pull_speed.select(j)\n                        time.sleep(1)\n                        setting_close_btn = app['血管内断层成像系统'].child_window(auto_id=\"closeSetting\", control_type=\"Button\")\n                        setting_close_btn.click()\n                        time.sleep(1)\n                        dsa = common_util.read_systemInfo()\n                        if dsa['DSA'] == True:\n                            dsa_btn = app['血管内断层成像系统'].child_window(title=\"显示DSA\", control_type=\"Text\", found_index=0)\n                            if dsa_btn.exists():\n                                dsa_btn = app['血管内断层成像系统'].child_window(title=\"显示DSA\", auto_id=\"btnShow\",control_type=\"Button\")\n                                dsa_btn.click_input()\n                        time.sleep(1)\n                        scan_btn = app['血管内断层成像系统'].child_window(auto_id=\"staScan\", control_type=\"Button\")\n                        scan_btn.click()\n                        time.sleep(5)\n                        if i == 0 and j == 0:\n                            calibration_btn = app['血管内断层成像系统'].child_window(auto_id=\"autoCalibration\",control_type=\"Button\")\n                            calibration_btn.click()\n                            time.sleep(13)\n                        ok_btn = app['提示'].child_window(title=\"确 定\", auto_id=\"OkButton\", control_type=\"Button\")\n                        if ok_btn.exists():\n                            ok_btn.click()\n                        else:\n                            stop_btn = app['血管内断层成像系统'].child_window(auto_id=\"stopScan\", control_type=\"Button\")\n                            stop_btn.click()\n                        scan_btn = app['血管内断层成像系统'].child_window(auto_id=\"staScan\", control_type=\"Button\")\n                        scan_btn.click()\n                        time.sleep(5)\n                        ready_btn = app['血管内断层成像系统'].child_window(auto_id=\"staScan\", control_type=\"Button\")\n                        ready_btn.click()\n                        time.sleep(5)\n                        pullback_btn = app['血管内断层成像系统'].child_window(auto_id=\"staScan\", control_type=\"Button\")\n                        pullback_btn.click()\n                        reset_btn = app['血管内断层成像系统'].child_window(title=\"校准\", auto_id=\"btnResetShrink\",control_type=\"Button\").wait('enabled', timeout=180)\n                        assert reset_btn.is_enabled()\n                        mm_pos = app['血管内断层成像系统'].child_window(title=\"mm\", control_type=\"Text\", found_index=0)\n                        rect = mm_pos.rectangle().mid_point()\n                        mouse.click(coords=(rect.x, rect.y))\n                        play_btn = app['血管内断层成像系统'].child_window(auto_id=\"playBtn\", control_type=\"Button\")\n                        rect = play_btn.rectangle().mid_point()\n                        mouse.click(coords=(rect.x, rect.y))\n                        clip_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClipImage\", control_type=\"Button\").wait(wait_for='enabled', timeout=12)\n                        if clip_btn.is_enabled():\n                            clip_btn = app['血管内断层成像系统'].child_window(auto_id=\"txtIndex\", control_type=\"Text\")\n                            frame_truth = int(clip_btn.texts()[0].split(': ')[-1])\n                            pullLen = content_len[i].split('mm')[0]\n                            pullSpeed = content_speed[j].split('mm')[0]\n                            frame_expect = int(int(pullLen) / int(pullSpeed) * 100)\n                            error = int(frame_expect * 0.05)\n                            common_util.screen_shot('距离/速度:{}-{},期望帧数：{}-实际帧数：{}'.format(content_len[i], content_speed[j],frame_expect, frame_truth))\n                            assert abs(frame_expect - frame_truth)< error\n                        time.sleep(1)\n                        add_btn = app['血管内断层成像系统'].child_window(auto_id=\"addOCT\", control_type=\"Button\")\n                        add_btn.click()\n                        time.sleep(1)\n        except Exception as e:\n            time.sleep(1)\n            common_util.screen_shot('异常截图')\n            time.sleep(1)\n            common_util.kill_app()\n            time.sleep(2)\n            common_util.connect_application()\n            common_util.add_text(str(e))\n>           assert False\nE           assert False\n\ntestcases\\scanImage\\test_scanImage.py:184: AssertionError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"_session_faker","time":{"start":1691373017956,"stop":1691373018017,"duration":61},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"stepsCount":0,"hasContent":false},{"name":"_xunit_setup_class_fixture_Test_ScanImagePage","time":{"start":1691373018017,"stop":1691373064081,"duration":46064},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"stepsCount":0,"hasContent":false},{"name":"_verify_url","time":{"start":1691373018017,"stop":1691373018017,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"stepsCount":0,"hasContent":false},{"name":"base_url","time":{"start":1691373018017,"stop":1691373018017,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"stepsCount":0,"hasContent":false},{"name":"environ","time":{"start":1691373018017,"stop":1691373018017,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"stepsCount":0,"hasContent":false}],"testStage":{"description":"回撤-6k","status":"failed","statusMessage":"AssertionError: assert False","statusTrace":"self = <pywinauto.application.WindowSpecification object at 0x0000028CA661A110>\ncriteria = [{'app': <pywinauto.application.Application object at 0x0000028CA6666F90>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False}]\ntimeout = 5.0, retry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n>           ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n                criteria)\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:250: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ntimeout = 5.0, retry_interval = 0.09\nfunc = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x0000028CA661A110>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'app': <pywinauto.application.Application object at 0x0000028CA6666F90>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False}],)\nkwargs = {}, start = 5527.1790851, time_left = -0.06389110000054643\nerr = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n                func_val = func(*args, **kwargs)\n    \n                # if no exception is raised then we are finished\n                break\n    \n            # An exception was raised - so wait and try again\n            except exceptions as e:\n    \n                # find out how much of the time is left\n                time_left = timeout - (timestamp() - start)\n    \n                # if we have to wait some more\n                if time_left > 0:\n                    # wait either the retry_interval or else the amount of\n                    # time until the timeout expires (whichever is less)\n                    time.sleep(min(retry_interval, time_left))\n    \n                else:\n                    # Raise a TimeoutError - and put the original exception\n                    # inside it\n                    err = TimeoutError()\n                    err.original_exception = e\n>                   raise err\nE                   pywinauto.timings.TimeoutError\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\timings.py:458: TimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_scanImage.Test_ScanImagePage object at 0x0000028CA54CE650>\n\n    @pytest.mark.test\n    @allure.title('回撤-6k')\n    def test_pullback_6k(self):\n        allure.dynamic.description('回撤-6k')\n        try:\n            app = common_util.connect_application()\n            common_util.back_scanImagePage()\n            with allure.step('6k:不同转速和距离'):\n                # 6k转\n                setting_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSetting\", control_type=\"Button\")\n                setting_btn.click_input()\n                play_type = app['血管内断层成像系统'].child_window(auto_id=\"comLoop\", control_type=\"ComboBox\", found_index=0)\n                play_type.select(0)\n                play_speed = app['血管内断层成像系统'].child_window(auto_id=\"playbackSpeed\", control_type=\"Slider\", found_index=0)\n                play_speed.set_value(10)\n                k6_btn = app['血管内断层成像系统'].child_window(title=\"6k转\", auto_id=\"rbRotateSpeed6000\",control_type=\"RadioButton\", found_index=0)\n                k6_btn.click()\n                pull_len = app['血管内断层成像系统'].child_window(auto_id=\"comPullback\", control_type=\"ComboBox\")\n                pull_len.select(0)\n                content_len = pull_len.texts()\n                for i in range(len(content_len)):\n                    setting_close_btn = app['血管内断层成像系统'].child_window(auto_id=\"closeSetting\", control_type=\"Button\")\n                    if setting_close_btn.exists() == False:\n                        setting_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSetting\", control_type=\"Button\")\n                        setting_btn.click_input()\n                    pull_len.select(i)\n                    pull_speed = app['血管内断层成像系统'].child_window(auto_id=\"comPullBackSped\",control_type=\"ComboBox\")\n                    pull_speed.select(0)\n                    content_speed = pull_speed.texts()\n                    for j in range(len(content_speed)):\n                        setting_close_btn = app['血管内断层成像系统'].child_window(auto_id=\"closeSetting\", control_type=\"Button\")\n                        if setting_close_btn.exists() == False:\n                            setting_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSetting\", control_type=\"Button\")\n                            setting_btn.click_input()\n                        pull_speed.select(j)\n                        time.sleep(1)\n                        setting_close_btn = app['血管内断层成像系统'].child_window(auto_id=\"closeSetting\", control_type=\"Button\")\n                        setting_close_btn.click()\n                        time.sleep(1)\n                        dsa = common_util.read_systemInfo()\n                        if dsa['DSA'] == True:\n                            dsa_btn = app['血管内断层成像系统'].child_window(title=\"显示DSA\", control_type=\"Text\", found_index=0)\n                            if dsa_btn.exists():\n                                dsa_btn = app['血管内断层成像系统'].child_window(title=\"显示DSA\", auto_id=\"btnShow\",control_type=\"Button\")\n                                dsa_btn.click_input()\n                        time.sleep(1)\n                        scan_btn = app['血管内断层成像系统'].child_window(auto_id=\"staScan\", control_type=\"Button\")\n                        scan_btn.click()\n                        time.sleep(5)\n                        if i == 0 and j == 0:\n                            calibration_btn = app['血管内断层成像系统'].child_window(auto_id=\"autoCalibration\",control_type=\"Button\")\n                            calibration_btn.click()\n                            time.sleep(13)\n                        ok_btn = app['提示'].child_window(title=\"确 定\", auto_id=\"OkButton\", control_type=\"Button\")\n                        if ok_btn.exists():\n                            ok_btn.click()\n                        else:\n                            stop_btn = app['血管内断层成像系统'].child_window(auto_id=\"stopScan\", control_type=\"Button\")\n>                           stop_btn.click()\n\ntestcases\\scanImage\\test_scanImage.py:145: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x0000028CA661A110>\nattr_name = 'click'\n\n    def __getattribute__(self, attr_name):\n        \"\"\"\n        Attribute access for this class\n    \n        If we already have criteria for both dialog and control then\n        resolve the control and return the requested attribute.\n    \n        If we have only criteria for the dialog but the attribute\n        requested is an attribute of DialogWrapper then resolve the\n        dialog and return the requested attribute.\n    \n        Otherwise delegate functionality to :func:`__getitem__` - which\n        sets the appropriate criteria for the control.\n        \"\"\"\n        allow_magic_lookup = object.__getattribute__(self, \"allow_magic_lookup\")  # Beware of recursions here!\n        if not allow_magic_lookup:\n            try:\n                return object.__getattribute__(self, attr_name)\n            except AttributeError:\n                wrapper_object = self.wrapper_object()\n                try:\n                    return getattr(wrapper_object, attr_name)\n                except AttributeError:\n                    message = (\n                        'Attribute \"%s\" exists neither on %s object nor on'\n                        'targeted %s element wrapper (typo? or set allow_magic_lookup to True?)' %\n                        (attr_name, self.__class__, wrapper_object.__class__))\n                    raise AttributeError(message)\n    \n        if attr_name in ['__dict__', '__members__', '__methods__', '__class__', '__name__']:\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in dir(self.__class__):\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in self.__dict__:\n            return self.__dict__[attr_name]\n    \n        # if we already have 2 levels of criteria (dlg, control)\n        # this third must be an attribute so resolve and get the\n        # attribute and return it\n        if len(self.criteria) >= 2:  # FIXME - this is surprising\n    \n>           ctrls = self.__resolve_control(self.criteria)\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:379: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x0000028CA661A110>\ncriteria = [{'app': <pywinauto.application.Application object at 0x0000028CA6666F90>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False}]\ntimeout = 5.0, retry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n            ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n                criteria)\n    \n        except TimeoutError as e:\n>           raise e.original_exception\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:261: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ntimeout = 5.0, retry_interval = 0.09\nfunc = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x0000028CA661A110>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'app': <pywinauto.application.Application object at 0x0000028CA6666F90>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False}],)\nkwargs = {}, start = 5527.1790851, time_left = -0.06389110000054643\nerr = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n>               func_val = func(*args, **kwargs)\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\timings.py:436: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x0000028CA661A110>\ncriteria_ = [{'app': <pywinauto.application.Application object at 0x0000028CA6666F90>, 'backend': 'uia', 'best_match': '血管内断层成像系统'}, {'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False}]\n\n    def __get_ctrl(self, criteria_):\n        \"\"\"Get a control based on the various criteria\"\"\"\n        # make a copy of the criteria\n        criteria = [crit.copy() for crit in criteria_]\n        # find the dialog\n        if 'backend' not in criteria[0]:\n            criteria[0]['backend'] = self.backend.name\n        if self.app is not None:\n            # find_elements(...) accepts only \"process\" argument\n            criteria[0]['process'] = self.app.process\n            del criteria[0]['app']\n        dialog = self.backend.generic_wrapper_class(findwindows.find_element(**criteria[0]))\n    \n        ctrls = []\n        # if there is only criteria for a dialog then return it\n        if len(criteria) > 1:\n            # so there was criteria for a control, add the extra criteria\n            # that are required for child controls\n            previous_parent = dialog.element_info\n            for ctrl_criteria in criteria[1:]:\n                ctrl_criteria[\"top_level_only\"] = False\n                if \"parent\" not in ctrl_criteria:\n                    ctrl_criteria[\"parent\"] = previous_parent\n    \n                if isinstance(ctrl_criteria[\"parent\"], WindowSpecification):\n                    ctrl_criteria[\"parent\"] = ctrl_criteria[\"parent\"].wrapper_object()\n    \n                # resolve the control and return it\n                if 'backend' not in ctrl_criteria:\n                    ctrl_criteria['backend'] = self.backend.name\n>               ctrl = self.backend.generic_wrapper_class(findwindows.find_element(**ctrl_criteria))\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py:222: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nkwargs = {'auto_id': 'stopScan', 'backend': 'uia', 'control_type': 'Button', 'parent': <uia_element_info.UIAElementInfo - '', , None>, ...}\nelements = []\n\n    def find_element(**kwargs):\n        \"\"\"\n        Call find_elements and ensure that only one element is returned\n    \n        Calls find_elements with exactly the same arguments as it is called with\n        so please see :py:func:`find_elements` for the full parameters description.\n        \"\"\"\n        elements = find_elements(**kwargs)\n    \n        if not elements:\n>           raise ElementNotFoundError(kwargs)\nE           pywinauto.findwindows.ElementNotFoundError: {'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False, 'parent': <uia_element_info.UIAElementInfo - '', , None>, 'backend': 'uia'}\n\nC:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\findwindows.py:87: ElementNotFoundError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_scanImage.Test_ScanImagePage object at 0x0000028CA54CE650>\n\n    @pytest.mark.test\n    @allure.title('回撤-6k')\n    def test_pullback_6k(self):\n        allure.dynamic.description('回撤-6k')\n        try:\n            app = common_util.connect_application()\n            common_util.back_scanImagePage()\n            with allure.step('6k:不同转速和距离'):\n                # 6k转\n                setting_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSetting\", control_type=\"Button\")\n                setting_btn.click_input()\n                play_type = app['血管内断层成像系统'].child_window(auto_id=\"comLoop\", control_type=\"ComboBox\", found_index=0)\n                play_type.select(0)\n                play_speed = app['血管内断层成像系统'].child_window(auto_id=\"playbackSpeed\", control_type=\"Slider\", found_index=0)\n                play_speed.set_value(10)\n                k6_btn = app['血管内断层成像系统'].child_window(title=\"6k转\", auto_id=\"rbRotateSpeed6000\",control_type=\"RadioButton\", found_index=0)\n                k6_btn.click()\n                pull_len = app['血管内断层成像系统'].child_window(auto_id=\"comPullback\", control_type=\"ComboBox\")\n                pull_len.select(0)\n                content_len = pull_len.texts()\n                for i in range(len(content_len)):\n                    setting_close_btn = app['血管内断层成像系统'].child_window(auto_id=\"closeSetting\", control_type=\"Button\")\n                    if setting_close_btn.exists() == False:\n                        setting_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSetting\", control_type=\"Button\")\n                        setting_btn.click_input()\n                    pull_len.select(i)\n                    pull_speed = app['血管内断层成像系统'].child_window(auto_id=\"comPullBackSped\",control_type=\"ComboBox\")\n                    pull_speed.select(0)\n                    content_speed = pull_speed.texts()\n                    for j in range(len(content_speed)):\n                        setting_close_btn = app['血管内断层成像系统'].child_window(auto_id=\"closeSetting\", control_type=\"Button\")\n                        if setting_close_btn.exists() == False:\n                            setting_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnSetting\", control_type=\"Button\")\n                            setting_btn.click_input()\n                        pull_speed.select(j)\n                        time.sleep(1)\n                        setting_close_btn = app['血管内断层成像系统'].child_window(auto_id=\"closeSetting\", control_type=\"Button\")\n                        setting_close_btn.click()\n                        time.sleep(1)\n                        dsa = common_util.read_systemInfo()\n                        if dsa['DSA'] == True:\n                            dsa_btn = app['血管内断层成像系统'].child_window(title=\"显示DSA\", control_type=\"Text\", found_index=0)\n                            if dsa_btn.exists():\n                                dsa_btn = app['血管内断层成像系统'].child_window(title=\"显示DSA\", auto_id=\"btnShow\",control_type=\"Button\")\n                                dsa_btn.click_input()\n                        time.sleep(1)\n                        scan_btn = app['血管内断层成像系统'].child_window(auto_id=\"staScan\", control_type=\"Button\")\n                        scan_btn.click()\n                        time.sleep(5)\n                        if i == 0 and j == 0:\n                            calibration_btn = app['血管内断层成像系统'].child_window(auto_id=\"autoCalibration\",control_type=\"Button\")\n                            calibration_btn.click()\n                            time.sleep(13)\n                        ok_btn = app['提示'].child_window(title=\"确 定\", auto_id=\"OkButton\", control_type=\"Button\")\n                        if ok_btn.exists():\n                            ok_btn.click()\n                        else:\n                            stop_btn = app['血管内断层成像系统'].child_window(auto_id=\"stopScan\", control_type=\"Button\")\n                            stop_btn.click()\n                        scan_btn = app['血管内断层成像系统'].child_window(auto_id=\"staScan\", control_type=\"Button\")\n                        scan_btn.click()\n                        time.sleep(5)\n                        ready_btn = app['血管内断层成像系统'].child_window(auto_id=\"staScan\", control_type=\"Button\")\n                        ready_btn.click()\n                        time.sleep(5)\n                        pullback_btn = app['血管内断层成像系统'].child_window(auto_id=\"staScan\", control_type=\"Button\")\n                        pullback_btn.click()\n                        reset_btn = app['血管内断层成像系统'].child_window(title=\"校准\", auto_id=\"btnResetShrink\",control_type=\"Button\").wait('enabled', timeout=180)\n                        assert reset_btn.is_enabled()\n                        mm_pos = app['血管内断层成像系统'].child_window(title=\"mm\", control_type=\"Text\", found_index=0)\n                        rect = mm_pos.rectangle().mid_point()\n                        mouse.click(coords=(rect.x, rect.y))\n                        play_btn = app['血管内断层成像系统'].child_window(auto_id=\"playBtn\", control_type=\"Button\")\n                        rect = play_btn.rectangle().mid_point()\n                        mouse.click(coords=(rect.x, rect.y))\n                        clip_btn = app['血管内断层成像系统'].child_window(auto_id=\"btnClipImage\", control_type=\"Button\").wait(wait_for='enabled', timeout=12)\n                        if clip_btn.is_enabled():\n                            clip_btn = app['血管内断层成像系统'].child_window(auto_id=\"txtIndex\", control_type=\"Text\")\n                            frame_truth = int(clip_btn.texts()[0].split(': ')[-1])\n                            pullLen = content_len[i].split('mm')[0]\n                            pullSpeed = content_speed[j].split('mm')[0]\n                            frame_expect = int(int(pullLen) / int(pullSpeed) * 100)\n                            error = int(frame_expect * 0.05)\n                            common_util.screen_shot('距离/速度:{}-{},期望帧数：{}-实际帧数：{}'.format(content_len[i], content_speed[j],frame_expect, frame_truth))\n                            assert abs(frame_expect - frame_truth)< error\n                        time.sleep(1)\n                        add_btn = app['血管内断层成像系统'].child_window(auto_id=\"addOCT\", control_type=\"Button\")\n                        add_btn.click()\n                        time.sleep(1)\n        except Exception as e:\n            time.sleep(1)\n            common_util.screen_shot('异常截图')\n            time.sleep(1)\n            common_util.kill_app()\n            time.sleep(2)\n            common_util.connect_application()\n            common_util.add_text(str(e))\n>           assert False\nE           assert False\n\ntestcases\\scanImage\\test_scanImage.py:184: AssertionError","steps":[{"name":"6k:不同转速和距离","time":{"start":1691373088314,"stop":1691373116642,"duration":28328},"status":"broken","statusMessage":"pywinauto.findwindows.ElementNotFoundError: {'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False, 'parent': <uia_element_info.UIAElementInfo - '血管内光学干涉断层成像系统', Window, 1115416>, 'backend': 'uia'}\n","statusTrace":"  File \"D:\\workspace\\pytest-VM1\\testcases\\scanImage\\test_scanImage.py\", line 145, in test_pullback_6k\n    stop_btn.click()\n    ^^^^^^^^^^^^^^\n  File \"C:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py\", line 379, in __getattribute__\n    ctrls = self.__resolve_control(self.criteria)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py\", line 261, in __resolve_control\n    raise e.original_exception\n  File \"C:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\timings.py\", line 436, in wait_until_passes\n    func_val = func(*args, **kwargs)\n               ^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\application.py\", line 222, in __get_ctrl\n    ctrl = self.backend.generic_wrapper_class(findwindows.find_element(**ctrl_criteria))\n                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Program Files\\Python311\\Lib\\site-packages\\pywinauto\\findwindows.py\", line 87, in find_element\n    raise ElementNotFoundError(kwargs)\n","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"attachmentsCount":0,"stepsCount":0,"hasContent":true}],"attachments":[{"uid":"d8ad78ea4bf39882","name":"异常截图","source":"d8ad78ea4bf39882.jpg","type":"image/jpg","size":64774},{"uid":"546ded21603e9cb8","name":"{'auto_id': 'stopScan', 'control_type': 'Button', 'top_level_only': False, 'parent': <uia_element_info.UIAElementInfo - '', , None>, 'backend': 'uia'}","source":"546ded21603e9cb8.txt","type":"text/plain","size":0}],"parameters":[],"shouldDisplayMessage":true,"attachmentsCount":2,"stepsCount":1,"hasContent":true},"afterStages":[{"name":"_xunit_setup_class_fixture_Test_ScanImagePage::0","time":{"start":1691373713347,"stop":1691373713347,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"stepsCount":0,"hasContent":false}],"labels":[{"name":"feature","value":"扫描图像界面"},{"name":"tag","value":"test"},{"name":"tag","value":"run(order=1)"},{"name":"parentSuite","value":"testcases.scanImage"},{"name":"suite","value":"test_scanImage"},{"name":"subSuite","value":"Test_ScanImagePage"},{"name":"host","value":"DESKTOP-8BNU2EL"},{"name":"thread","value":"924-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"testcases.scanImage.test_scanImage"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"tags":["test","run(order=1)"]},"source":"ca8a55cdc611ad25.json","parameterValues":[]}